{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"AirStack","text":"<p>Welcome to the AirLab Autonomy Stack!</p> <p>It is maintained by the AirLab at Carnegie Mellon University's Robotics Institute.</p> <p>Please head to our Getting Started page to start.</p>"},{"location":"about/","title":"About","text":"<p>This stack is built by the AirLab at Carnegie Mellon University's Robotics Institute. Our main site is https://theairlab.org. The stack is maintained by Andrew Jong and John Keller.</p>"},{"location":"developer_guide/contributing/","title":"Contributing","text":"<p>This page describes how to merge content back into main.</p>"},{"location":"developer_guide/contributing/#dependencies","title":"Dependencies","text":"<p>Make sure to add your ROS2 package dependencies to your <code>package.xml</code> file. These get installed when the docker image is built.</p> <p>If you need to add a dependency that's not in the docker image, please add a section to the <code>Dockerfile</code> in the <code>docker/</code> directory.</p>"},{"location":"developer_guide/contributing/#documentation","title":"Documentation","text":"<p>Please make sure to document your work. Docs are under <code>AirStack/docs/</code></p> <p>This documentation is built with Material MKDocs</p> <p>For full documentation visit mkdocs.org. and mkdocs-material</p>"},{"location":"developer_guide/contributing/#commands","title":"Commands","text":"<pre><code>pip install mkdocs-material\nmkdocs serve\n</code></pre> <ul> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"developer_guide/contributing/#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"developer_guide/contributing/#merge","title":"Merge","text":"<p>Submit a pull request.</p>"},{"location":"developer_guide/overview/","title":"Developer Guide","text":"<p>Welcome developers! This guide documents how to extend the autonomy stack for your own needs. The stack has been designed with modularity in mind, and aims to make it straight forward to swap out any component.</p> <pre><code># clean workspace, removes all build and install directories\ncws \n# build workspace and source workspace. these are aliases in ~/.bashrc\nbws &amp;&amp; sws  \n</code></pre>"},{"location":"developer_guide/simulation/","title":"Simulation","text":"<p>Code located in <code>AirStack/simulation/</code></p>"},{"location":"developer_guide/simulation/#types-of-simulation","title":"Types of Simulation","text":""},{"location":"developer_guide/simulation/#simulation-engine","title":"Simulation Engine","text":"<p>For graphics and dynamics</p>"},{"location":"developer_guide/simulation/#softwarehardware-in-the-loop","title":"Software/Hardware in the Loop","text":"<p>For drone dynamics</p>"},{"location":"developer_guide/autonomy/controls/","title":"Controls","text":"<p>Code located in <code>AirStack/ros_ws/src/robot/autonomy/controls/</code>.</p>"},{"location":"developer_guide/autonomy/controls/#launch","title":"Launch","text":"<p>Launch files are under <code>src/robot/autonomy/controls/controls_bringup/launch</code>.</p> <p>Can be launched with <code>ros2 launch controls_bringup launch_controls.yaml</code></p>"},{"location":"developer_guide/autonomy/controls/#robotinterface","title":"RobotInterface","text":"<p>Package <code>robot_interface</code> is a ROS2 node that interfaces with the robot's hardware. The <code>RobotInterface</code> gets robot state and forwards it to the autonomy stack,  and also translates control commands from the autonomy stack into the command for the underlying hardware. Note the base class is unimplemented. Specific implementations should extend <code>class RobotInterface</code> in <code>robot_interface.hpp</code>, for example MAVROSInterface.</p>"},{"location":"developer_guide/autonomy/controls/#state","title":"State","text":"<p>The <code>RobotInterface</code> broadcasts the robot's pose as a TF2 transform. It also publishes the robot's odometry as a <code>nav_msgs/Odometry</code> message to <code>$(arg robot_name)/controls/robot_interface/odometry</code>.</p>"},{"location":"developer_guide/autonomy/controls/#commands","title":"Commands","text":"<p>The commands are variations of the two main command modes: Attitude control and Position control. These are reflected in MAVLink and supported by both PX4 and Ardupilot.</p> <p>The RobotInterface node subscribes to:</p> <ul> <li><code>$(arg robot_name)/controls/robot_interface/cmd_attitude_thrust</code> of type <code>mav_msgs/AttitudeThrust.msg</code></li> <li><code>$(arg robot_name)/controls/robot_interface/cmd_rate_thrust</code> of type <code>mav_msgs/RateThrust.msg</code></li> <li><code>$(arg robot_name)/controls/robot_interface/cmd_roll_pitch_yawrate_thrust</code> of type <code>mav_msgs/RollPitchYawrateThrust.msg</code></li> <li><code>$(arg robot_name)/controls/robot_interface/cmd_torque_thrust</code> of type <code>mav_msgs/TorqueThrust.msg</code></li> <li><code>$(arg robot_name)/controls/robot_interface/cmd_velocity</code> of type <code>geometry_msgs/TwistStamped.msg</code></li> <li><code>$(arg robot_name)/controls/robot_interface/cmd_position</code> of type <code>geometry_msgs/PoseStamped.msg</code></li> </ul> <p>All messages are in the robot's body frame, except <code>velocity</code> and <code>position</code> which use the frame specified by the message header.</p>"},{"location":"developer_guide/autonomy/controls/#custom-robot-interface","title":"Custom Robot Interface","text":"<p>Implementations should do the following:</p>"},{"location":"developer_guide/autonomy/controls/#broadcast-state","title":"Broadcast State","text":"<p>Implementations of <code>RobotInterface</code> should obtain the robot's pose and broadcast it as a TF2 transform.</p> <p>Should look something like: <pre><code>// callback function triggered by some loop\nvoid your_callback_function(){\n    // ...\n    geometry_msgs::msg::TransformStamped t;\n    // populate the transform, e.g.:\n    t.header = // some header\n    t.transform.translation.x = // some value\n    t.transform.translation.y = // some value\n    t.transform.translation.z = // some value\n    t.transform.rotation = // some quaternion\n    // Send the transformation\n    this-&gt;tf_broadcaster_-&gt;sendTransform(t);\n    // ...\n}\n</code></pre></p>"},{"location":"developer_guide/autonomy/controls/#override-command-handling","title":"Override Command Handling","text":"<p>Should override all <code>virtual</code> functions in <code>robot_interface.hpp</code>:</p> <ul> <li><code>cmd_attitude_thrust_callback</code></li> <li><code>cmd_rate_thrust_callback</code></li> <li><code>cmd_roll_pitch_yawrate_thrust_callback</code></li> <li><code>cmd_torque_thrust_callback</code></li> <li><code>cmd_velocity_callback</code></li> <li><code>cmd_position_callback</code></li> <li><code>request_control</code></li> <li><code>arm</code></li> <li><code>disarm</code></li> <li><code>is_armed</code></li> <li><code>has_control</code></li> </ul>"},{"location":"developer_guide/autonomy/global_planning/","title":"Global Planning","text":"<p>Global planners output a high level, coarse trajectory for the robot to follow. </p> <p>A trajectory is a spatial path plus a schedule.  This means each waypoint in the trajectory has a time associated with it, indicating when the robot should reach that waypoint. These timestamps are fed to the local planner to determine speed and acceleration.</p> <p>If a waypoint's header timestamp is empty, the local planner should assume there's no time constraint and follow the trajectory at its own pace.</p> <p>The global planner should make a trajectory that is collision-free according to the global map. However, avoiding fine obstacles is delegated to the local planner that operates at a faster rate.</p>"},{"location":"developer_guide/autonomy/global_planning/#ros-interfaces","title":"ROS Interfaces","text":""},{"location":"developer_guide/autonomy/global_planning/#actions-interface","title":"Actions Interface","text":"<p>The global planner should provide an action server for the topic <code>$(arg robot_name)/global_planner/plan</code> of message type <code>nav_msgs/GetPlan</code>.</p> <pre><code>\n</code></pre>"},{"location":"developer_guide/autonomy/global_planning/#subscribers","title":"Subscribers","text":"<p>In general, the global planner needs access to components of the world model.</p> <p>The most common one is the Occupancy Grids, which are published by the <code>map_server</code> node.</p>"},{"location":"developer_guide/autonomy/global_planning/#publishers","title":"Publishers","text":"<p>The global planner must publish a trajectory to the topic <code>$(arg robot_name)/global_planner/trajectory</code> of message type <code>nav_msgs/Path</code>.</p> <p>The header of the <code>nav_msgs/Path</code> message should contain the coordinate frame of the trajectory, and the timestamp should indicate when the trajectory was generated. Each waypoint's header should contain the coordinate frame of the waypoint, and the timestamp should indicate when the waypoint should be reached.</p> <pre><code>nav_msgs/Path.msg\n    - std_msgs/Header header\n        - time stamp: when the trajectory was generated\n        - frame_id: the coordinate frame of the trajectory\n    - geometry_msgs/PoseStamped[] poses: the trajectory\n        - geometry_msgs/PoseStamped pose\n            - std_msgs/Header header\n                - time stamp: when the waypoint should be reached\n                - string frame_id: the coordinate frame of the waypoint\n            - geometry_msgs/Pose pose: the position and orientation of the waypoint\n</code></pre> <p>The global planner can do whatever it wants internally.</p>"},{"location":"developer_guide/autonomy/local_planning/","title":"Local Planning","text":"<p>Local planner</p> <p>Part of the local planner is the Waypoint Manager.</p> <p>The Waypoint Manager subscribes to the global waypoints and the drone's current position and publishes the next waypoint to the local planner.</p>"},{"location":"user_guide/getting_started/","title":"Getting Started","text":"<p>Welcome to the AirLab Autonomy Stack. By the end of this guide, you will have the autonomy stack running on your machine.</p>"},{"location":"user_guide/getting_started/#requirements","title":"Requirements","text":"<p>You need at least 25GB free to install the Docker image.</p> <p>Have an NVIDIA GPU &gt;= RTX 3070 to run Isaac Sim locally.</p>"},{"location":"user_guide/getting_started/#setup","title":"Setup","text":""},{"location":"user_guide/getting_started/#clone","title":"Clone","text":"<pre><code>git clone --recursive -j8 git@github.com:castacks/AirStack.git\n</code></pre>"},{"location":"user_guide/getting_started/#omniverse","title":"Omniverse","text":"<p>Install the Omniverse launcher download from this link:</p> <pre><code>wget https://install.launcher.omniverse.nvidia.com/installers/omniverse-launcher-linux.AppImage\n</code></pre> <p>Follow these instructions to setup Nucleus : https://airlab.slite.com/app/docs/X8dZ8w5S3GP9tw</p>"},{"location":"user_guide/getting_started/#sitl","title":"SITL","text":"<p>If you are using the Ascent Spirit drone download the SITL software packages from this link: https://drive.google.com/file/d/1UxgezaTrHe4WJ28zsVeRhv1VYfOU5VK8/view?usp=drive_link</p> <p>Then unzip the file AscentAeroSystemsSITLPackage.zip in this folder:</p> <pre><code>cd AirStack/simulation/AscentAeroSystems\nunzip ~/Downloads/AscentAeroSystemsSITLPackage.zip -d .\n</code></pre>"},{"location":"user_guide/getting_started/#docker","title":"Docker","text":"<ul> <li>Install Docker Desktop. This should come installed with docker compose.</li> <li>Gain access to NVIDIA NGC Containers by following these instructions</li> </ul>"},{"location":"user_guide/getting_started/#build-and-run-the-docker-image","title":"Build and run the Docker image","text":"<pre><code>cd AirStack/docker/\n## build the image, it is named airlab-autonomy-dev:latest\ndocker compose --profile build build\n## start docker compose service/container\ndocker compose up -d\n</code></pre>"},{"location":"user_guide/getting_started/#launch","title":"Launch","text":"<p>Launch autonomy stack controls package:</p> <pre><code># start a new terminal in docker container\ndocker compose exec airstack_dev bash\n\n# in docker\nbws &amp;&amp; sws ## build workspace and source workspace. these are aliases in ~/.bashrc\nros2 launch robot_bringup launch_robot.yaml\n</code></pre> <p>Launch simulator (Isaac Sim and Ascent SITL):</p> <pre><code>xhost +  ## allow Docker access to Linux X-Server\n# start another terminal in docker container\ndocker compose exec airstack_dev bash\n\n# in docker\nISAACSIM_PYTHON simulation/launch_sim.py\n</code></pre>"},{"location":"user_guide/getting_started/#move-robot","title":"Move Robot","text":"<pre><code># start another terminal in docker container\ndocker compose exec airstack_dev bash\n\n# in docker\n# set drone mode to GUIDED\nros2 service call /robot1/controls/mavros/set_mode mavros_msgs/SetMode \"custom_mode: 'GUIDED'\"\n# ARM\nros2 service call /robot1/controls/mavros/cmd/arming mavros_msgs/srv/CommandBool \"{value: True}\"\n# TAKEOFF\nros2 service call /robot1/controls/mavros/cmd/takeoff mavros_msgs/srv/CommandTOL \"{altitude: 5}\"\n# FLY TO POSITION. Put whatever position you want\nros2 topic pub /controls/mavros/setpoint_position/local geometry_msgs/PoseStamped \\\n    \"{ header: { stamp: { sec: 0, nanosec: 0 }, frame_id: 'base_link' }, \\\n    pose: { position: { x: 10.0, y: 0.0, z: 20.0 }, orientation: { x: 0.0, y: 0.0, z: 0.0, w: 1.0 } } }\" -1\n</code></pre>"},{"location":"user_guide/isaac_sim/","title":"Isaac sim","text":"<p>Will create </p> <p>The docker container will cache Nucleus assets to ~/docker/isaac-sim on your host. Keep this folder to prevent re-downloading assets from Nucleus each time.</p>"},{"location":"user_guide/planners/","title":"Planners","text":"<p>Planners are the core of the <code>planner</code> module. They are responsible for generating a plan for the robot to follow. The <code>planner</code> module provides a number of planners that can be used to generate plans for the robot to follow. The planners are divided into two categories: trivial planners and advanced planners.</p>"},{"location":"user_guide/planners/#trivial-planners","title":"Trivial Planners","text":""},{"location":"user_guide/planners/#random-walk-planner","title":"Random Walk planner","text":"<p>The random walk planner generates</p> <p>The random walk planner replans when the robot is getting close to the goal. The random walk planner is a trivial planner that generates a plan by randomly selecting a direction to move in. The random walk planner is useful for testing the robot's ability to follow a plan.</p>"},{"location":"user_guide/tutorials/launch/","title":"Launch","text":"<p>Modules can be launched individually. For example, to launch controls only: <pre><code>ros2 launch controls_bringup controls_launch.yaml\n</code></pre></p>"},{"location":"user_guide/tutorials/overview/","title":"Tutorials Overview","text":""}]}